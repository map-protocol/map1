<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MAP v1 Playground</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=DM+Sans:wght@400;500;700&display=swap');

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #0c0e12;
    --surface: #13161c;
    --surface-2: #1a1e26;
    --border: #252a35;
    --border-focus: #3d4556;
    --text: #c8cdd8;
    --text-dim: #6b7385;
    --text-bright: #e8ecf4;
    --accent: #5de4a7;
    --accent-dim: #2a7a55;
    --error: #f07178;
    --warn: #f0c678;
    --mid-color: #7dc4e4;
    --mono: 'JetBrains Mono', monospace;
    --sans: 'DM Sans', system-ui, sans-serif;
  }

  html { font-size: 15px; }

  body {
    font-family: var(--sans);
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    line-height: 1.6;
  }

  /* ── header ── */
  header {
    border-bottom: 1px solid var(--border);
    padding: 1.5rem 2rem;
    display: flex;
    align-items: baseline;
    gap: 1rem;
    flex-wrap: wrap;
  }

  header h1 {
    font-family: var(--mono);
    font-size: 1.1rem;
    font-weight: 700;
    color: var(--accent);
    letter-spacing: 0.05em;
  }

  header h1 span {
    color: var(--text-dim);
    font-weight: 400;
  }

  header .tagline {
    font-size: 0.85rem;
    color: var(--text-dim);
  }

  header .links {
    margin-left: auto;
    display: flex;
    gap: 1.2rem;
    font-size: 0.8rem;
  }

  header .links a {
    color: var(--text-dim);
    text-decoration: none;
    font-family: var(--mono);
    transition: color 0.15s;
  }

  header .links a:hover { color: var(--accent); }

  /* ── main layout ── */
  main {
    max-width: 960px;
    margin: 0 auto;
    padding: 2rem;
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }

  /* ── panels ── */
  .panel {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    overflow: hidden;
  }

  .panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.6rem 1rem;
    background: var(--surface-2);
    border-bottom: 1px solid var(--border);
    font-family: var(--mono);
    font-size: 0.75rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.1em;
  }

  .panel-body { padding: 1rem; }

  /* ── editor ── */
  #input-json {
    width: 100%;
    min-height: 140px;
    background: var(--bg);
    color: var(--text-bright);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 0.8rem 1rem;
    font-family: var(--mono);
    font-size: 0.85rem;
    line-height: 1.6;
    resize: vertical;
    outline: none;
    transition: border-color 0.15s;
  }

  #input-json:focus { border-color: var(--accent-dim); }

  /* ── controls row ── */
  .controls {
    display: flex;
    gap: 0.8rem;
    align-items: center;
    flex-wrap: wrap;
  }

  .mode-group {
    display: flex;
    gap: 0;
    border: 1px solid var(--border);
    border-radius: 4px;
    overflow: hidden;
  }

  .mode-btn {
    background: var(--surface-2);
    color: var(--text-dim);
    border: none;
    padding: 0.45rem 1rem;
    font-family: var(--mono);
    font-size: 0.78rem;
    cursor: pointer;
    transition: all 0.15s;
    border-right: 1px solid var(--border);
  }

  .mode-btn:last-child { border-right: none; }
  .mode-btn:hover { color: var(--text); }
  .mode-btn.active {
    background: var(--accent-dim);
    color: var(--accent);
  }

  #pointers-input {
    flex: 1;
    min-width: 200px;
    background: var(--bg);
    color: var(--text-bright);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 0.45rem 0.8rem;
    font-family: var(--mono);
    font-size: 0.78rem;
    outline: none;
    transition: border-color 0.15s;
  }

  #pointers-input:focus { border-color: var(--accent-dim); }
  #pointers-input.hidden { display: none; }

  .compute-btn {
    background: var(--accent-dim);
    color: var(--accent);
    border: 1px solid var(--accent);
    padding: 0.45rem 1.4rem;
    font-family: var(--mono);
    font-size: 0.78rem;
    font-weight: 700;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.15s;
    letter-spacing: 0.05em;
    text-transform: uppercase;
  }

  .compute-btn:hover {
    background: var(--accent);
    color: var(--bg);
  }

  .compute-btn:active { transform: scale(0.97); }

  /* ── output ── */
  .output-section { display: flex; flex-direction: column; gap: 1rem; }

  .mid-display {
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 1rem;
    font-family: var(--mono);
    font-size: 0.9rem;
    word-break: break-all;
    color: var(--mid-color);
    position: relative;
    min-height: 2.8rem;
    display: flex;
    align-items: center;
    cursor: pointer;
    transition: border-color 0.15s;
  }

  .mid-display:hover { border-color: var(--mid-color); }

  .mid-display .prefix {
    color: var(--text-dim);
    user-select: all;
  }

  .mid-display .hash {
    color: var(--mid-color);
    user-select: all;
  }

  .mid-display.error { color: var(--error); border-color: #3d2020; }
  .mid-display.error:hover { border-color: var(--error); }
  .mid-display.empty { color: var(--text-dim); font-style: italic; font-size: 0.8rem; }

  .copy-toast {
    position: absolute;
    right: 0.8rem;
    top: 50%;
    transform: translateY(-50%);
    background: var(--accent);
    color: var(--bg);
    padding: 0.15rem 0.5rem;
    border-radius: 3px;
    font-size: 0.7rem;
    font-weight: 700;
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
  }

  .copy-toast.show { opacity: 1; }

  /* ── hex dump ── */
  .hex-toggle {
    background: none;
    border: 1px solid var(--border);
    color: var(--text-dim);
    font-family: var(--mono);
    font-size: 0.7rem;
    padding: 0.25rem 0.6rem;
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.15s;
  }

  .hex-toggle:hover { color: var(--text); border-color: var(--border-focus); }
  .hex-toggle.active { color: var(--accent); border-color: var(--accent-dim); }

  .hex-dump {
    display: none;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 0.8rem 1rem;
    font-family: var(--mono);
    font-size: 0.75rem;
    line-height: 1.8;
    color: var(--text-dim);
    overflow-x: auto;
  }

  .hex-dump.show { display: block; }

  .hex-dump .hdr { color: var(--warn); }
  .hex-dump .tag { color: var(--accent); }
  .hex-dump .len { color: var(--text-dim); }
  .hex-dump .payload { color: var(--text-bright); }
  .hex-dump .offset { color: #4a5068; user-select: none; }

  /* ── info bar ── */
  .info-bar {
    display: flex;
    gap: 2rem;
    font-family: var(--mono);
    font-size: 0.72rem;
    color: var(--text-dim);
    padding: 0.5rem 0;
    flex-wrap: wrap;
  }

  .info-bar .stat span { color: var(--text); }

  /* ── examples ── */
  .examples {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
  }

  .example-btn {
    background: var(--surface-2);
    border: 1px solid var(--border);
    color: var(--text-dim);
    font-family: var(--mono);
    font-size: 0.72rem;
    padding: 0.3rem 0.7rem;
    border-radius: 3px;
    cursor: pointer;
    transition: all 0.15s;
  }

  .example-btn:hover { color: var(--text); border-color: var(--border-focus); }

  /* ── footer ── */
  footer {
    max-width: 960px;
    margin: 0 auto;
    padding: 0 2rem 2rem;
    font-size: 0.75rem;
    color: var(--text-dim);
    font-family: var(--mono);
  }

  footer a { color: var(--text-dim); text-decoration: none; }
  footer a:hover { color: var(--accent); }

  /* ── responsive ── */
  @media (max-width: 640px) {
    header { padding: 1rem; }
    main { padding: 1rem; }
    .controls { flex-direction: column; align-items: stretch; }
    .mode-group { align-self: flex-start; }
    header .links { margin-left: 0; }
  }
</style>
</head>
<body>

<header>
  <h1>MAP1 <span>playground</span></h1>
  <span class="tagline">Deterministic identity for structured data</span>
  <nav class="links">
    <a href="https://github.com/map-protocol/map1">github</a>
    <a href="https://github.com/map-protocol/map1/blob/main/spec/MAP_v1.0.md">spec</a>
    <a href="https://github.com/map-protocol/map1/blob/main/docs/quickstart_10min.md">quickstart</a>
  </nav>
</header>

<main>

  <!-- Input -->
  <div class="panel">
    <div class="panel-header">
      <span>input · json</span>
      <div class="examples">
        <button class="example-btn" data-example="deploy">deploy</button>
        <button class="example-btn" data-example="nested">nested</button>
        <button class="example-btn" data-example="reorder">reorder</button>
        <button class="example-btn" data-example="bool">booleans</button>
        <button class="example-btn" data-example="error-num">error: number</button>
        <button class="example-btn" data-example="error-dup">error: dup key</button>
      </div>
    </div>
    <div class="panel-body">
      <textarea id="input-json" spellcheck="false">{"action": "deploy", "target": "prod", "version": "2.1.0"}</textarea>
    </div>
  </div>

  <!-- Controls -->
  <div class="controls">
    <div class="mode-group">
      <button class="mode-btn active" data-mode="full">FULL</button>
      <button class="mode-btn" data-mode="bind">BIND</button>
    </div>
    <input type="text" id="pointers-input" class="hidden" placeholder="/field1 /field2 ..." value="/action /target">
    <button class="compute-btn" id="compute-btn">Compute MID</button>
  </div>

  <!-- Output -->
  <div class="panel">
    <div class="panel-header">
      <span>output · mid</span>
      <button class="hex-toggle" id="hex-toggle">canon bytes</button>
    </div>
    <div class="panel-body output-section">
      <div class="mid-display empty" id="mid-output">
        paste json and click compute
        <span class="copy-toast" id="copy-toast">copied</span>
      </div>
      <div class="hex-dump" id="hex-dump"></div>
      <div class="info-bar" id="info-bar"></div>
    </div>
  </div>

</main>

<footer>
  MAP v1.0 · MIT License · <a href="https://github.com/map-protocol/map1">map-protocol/map1</a>
  · pip install map1 · npm install map1
</footer>

<script>
// ════════════════════════════════════════════════════
// MAP v1.0 — Complete browser implementation
// Ported from the Node reference implementation
// Zero dependencies, uses Web Crypto API
// ════════════════════════════════════════════════════

const CANON_HDR = new Uint8Array([0x4d, 0x41, 0x50, 0x31, 0x00]); // "MAP1\0"
const TAG_STRING = 0x01, TAG_BYTES = 0x02, TAG_LIST = 0x03, TAG_MAP = 0x04;
const MAX_CANON_BYTES = 1048576, MAX_DEPTH = 32, MAX_MAP_ENTRIES = 65535, MAX_LIST_ENTRIES = 65535;

class MapError extends Error {
  constructor(code, msg) { super(msg || code); this.code = code; }
}

// ── helpers ──

function u8concat(...arrs) {
  let len = 0;
  for (const a of arrs) len += a.length;
  const out = new Uint8Array(len);
  let off = 0;
  for (const a of arrs) { out.set(a, off); off += a.length; }
  return out;
}

function u32be(n) {
  return new Uint8Array([(n >>> 24) & 0xff, (n >>> 16) & 0xff, (n >>> 8) & 0xff, n & 0xff]);
}

const encoder = new TextEncoder();
const decoder = new TextDecoder("utf-8", { fatal: true });

function strToUtf8(s) { return encoder.encode(s); }

function rejectSurrogates(s) {
  for (let i = 0; i < s.length; i++) {
    const c = s.charCodeAt(i);
    if (c >= 0xd800 && c <= 0xdbff) {
      if (i + 1 < s.length) {
        const c2 = s.charCodeAt(i + 1);
        if (c2 >= 0xdc00 && c2 <= 0xdfff) { i++; continue; }
      }
      throw new MapError("ERR_UTF8", "unpaired surrogate");
    }
    if (c >= 0xdc00 && c <= 0xdfff) throw new MapError("ERR_UTF8", "unpaired surrogate");
  }
}

function validateUtf8Scalar(bytes) {
  let s;
  try { s = decoder.decode(bytes); } catch { throw new MapError("ERR_UTF8", "invalid utf-8"); }
  rejectSurrogates(s);
  return s;
}

function keyCmp(a, b) {
  const m = Math.min(a.length, b.length);
  for (let i = 0; i < m; i++) {
    if (a[i] !== b[i]) return a[i] < b[i] ? -1 : 1;
  }
  if (a.length === b.length) return 0;
  return a.length < b.length ? -1 : 1;
}

async function sha256hex(data) {
  const hash = await crypto.subtle.digest("SHA-256", data);
  return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
}

// ── MCF encode ──

function mcfEncode(val, depth) {
  if (typeof val === "string") {
    const b = strToUtf8(val);
    rejectSurrogates(val);
    return u8concat(new Uint8Array([TAG_STRING]), u32be(b.length), b);
  }
  if (val instanceof Uint8Array) {
    return u8concat(new Uint8Array([TAG_BYTES]), u32be(val.length), val);
  }
  if (Array.isArray(val)) {
    if (depth + 1 > MAX_DEPTH) throw new MapError("ERR_LIMIT_DEPTH", "depth");
    if (val.length > MAX_LIST_ENTRIES) throw new MapError("ERR_LIMIT_SIZE", "list");
    const parts = [new Uint8Array([TAG_LIST]), u32be(val.length)];
    for (const it of val) parts.push(mcfEncode(it, depth + 1));
    return u8concat(...parts);
  }
  if (val && typeof val === "object") {
    if (depth + 1 > MAX_DEPTH) throw new MapError("ERR_LIMIT_DEPTH", "depth");
    const keys = Object.keys(val);
    const keyBytes = keys.map(k => [k, strToUtf8(k)]);
    keyBytes.sort((a, b) => keyCmp(a[1], b[1]));
    for (let i = 1; i < keyBytes.length; i++) {
      const c = keyCmp(keyBytes[i-1][1], keyBytes[i][1]);
      if (c === 0) throw new MapError("ERR_DUP_KEY", "dup");
      if (c > 0) throw new MapError("ERR_KEY_ORDER", "order");
    }
    if (keyBytes.length > MAX_MAP_ENTRIES) throw new MapError("ERR_LIMIT_SIZE", "map");
    const parts = [new Uint8Array([TAG_MAP]), u32be(keyBytes.length)];
    for (const [k, kb] of keyBytes) {
      parts.push(u8concat(new Uint8Array([TAG_STRING]), u32be(kb.length), kb));
      parts.push(mcfEncode(val[k], depth + 1));
    }
    return u8concat(...parts);
  }
  throw new MapError("ERR_SCHEMA", "unsupported type");
}

function canonBytes(val) {
  const body = mcfEncode(val, 0);
  const canon = u8concat(CANON_HDR, body);
  if (canon.length > MAX_CANON_BYTES) throw new MapError("ERR_LIMIT_SIZE", "too big");
  return canon;
}

// ── JSON-STRICT parser ──

function parseJsonStrict(raw) {
  if (raw.length > MAX_CANON_BYTES) throw new MapError("ERR_LIMIT_SIZE", "input too big");

  // BOM check
  let ws = 0;
  while (ws < raw.length && (raw[ws]===0x20||raw[ws]===0x09||raw[ws]===0x0a||raw[ws]===0x0d)) ws++;
  if (ws+3 <= raw.length && raw[ws]===0xef && raw[ws+1]===0xbb && raw[ws+2]===0xbf)
    throw new MapError("ERR_SCHEMA", "BOM");

  let text;
  try { text = decoder.decode(raw); } catch { throw new MapError("ERR_UTF8", "bad utf-8"); }

  let i = 0, dupFound = false, surrogateFound = false;

  function skipWS() { while (i < text.length && /\s/.test(text[i])) i++; }
  function expect(ch) { skipWS(); if (text[i] !== ch) throw new MapError("ERR_CANON_MCF","json"); i++; }

  function parseString() {
    if (text[i] !== '"') throw new MapError("ERR_CANON_MCF","json");
    i++;
    let out = "", closed = false;
    while (i < text.length) {
      const ch = text[i++];
      if (ch.charCodeAt(0) < 0x20) throw new MapError("ERR_CANON_MCF","json");
      if (ch === '"') { closed = true; break; }
      if (ch === '\\') {
        if (i >= text.length) throw new MapError("ERR_CANON_MCF","json");
        const esc = text[i++];
        if (esc==='"'||esc==='\\'||esc==='/') out += esc;
        else if (esc==='b') out += '\b';
        else if (esc==='f') out += '\f';
        else if (esc==='n') out += '\n';
        else if (esc==='r') out += '\r';
        else if (esc==='t') out += '\t';
        else if (esc==='u') {
          const hex = text.slice(i, i+4);
          if (!/^[0-9a-fA-F]{4}$/.test(hex)) throw new MapError("ERR_CANON_MCF","json");
          const code = parseInt(hex, 16);
          i += 4;
          if (code >= 0xd800 && code <= 0xdfff) { surrogateFound = true; }
          else { out += String.fromCodePoint(code); }
        } else throw new MapError("ERR_CANON_MCF","json");
      } else { out += ch; }
    }
    if (!closed) throw new MapError("ERR_CANON_MCF","json");
    rejectSurrogates(out);
    return out;
  }

  function parseValue() {
    skipWS();
    if (i >= text.length) throw new MapError("ERR_CANON_MCF","json");
    const c = text[i];
    if (c === '{') return parseObject();
    if (c === '[') return parseArray();
    if (c === '"') return parseString();
    if (c === 't' && text.startsWith('true',i)) { i+=4; return true; }
    if (c === 'f' && text.startsWith('false',i)) { i+=5; return false; }
    if (c === 'n' && text.startsWith('null',i)) { i+=4; return null; }
    if (c === '-' || (c >= '0' && c <= '9')) {
      const m = text.slice(i).match(/^-?(0|[1-9]\d*)(\.\d+)?([eE][+-]?\d+)?/);
      if (!m) throw new MapError("ERR_CANON_MCF","json");
      i += m[0].length;
      return {__num__: m[0]};
    }
    throw new MapError("ERR_CANON_MCF","json");
  }

  function parseObject() {
    const obj = {}, seen = new Set();
    i++; skipWS();
    if (text[i] === '}') { i++; return obj; }
    while (true) {
      skipWS();
      const key = parseString();
      if (seen.has(key)) {
        dupFound = true;
        skipWS(); expect(':'); parseValue(); skipWS();
        if (text[i] === '}') { i++; break; }
        expect(','); continue;
      }
      seen.add(key);
      skipWS(); expect(':');
      obj[key] = parseValue();
      skipWS();
      if (text[i] === '}') { i++; break; }
      expect(',');
    }
    return obj;
  }

  function parseArray() {
    const arr = [];
    i++; skipWS();
    if (text[i] === ']') { i++; return arr; }
    while (true) {
      arr.push(parseValue());
      skipWS();
      if (text[i] === ']') { i++; break; }
      expect(',');
    }
    return arr;
  }

  const v = parseValue();
  skipWS();
  if (i !== text.length) throw new MapError("ERR_CANON_MCF","trailing");
  return { v, dupFound, surrogateFound };
}

function jsonToCanon(x) {
  if (x && typeof x === 'object' && '__num__' in x) throw new MapError("ERR_TYPE","number");
  if (x === null) throw new MapError("ERR_TYPE","null");
  if (typeof x === 'boolean') return x ? "true" : "false";
  if (typeof x === 'string') return x;
  if (Array.isArray(x)) return x.map(jsonToCanon);
  if (typeof x === 'object') {
    const out = {};
    for (const k of Object.keys(x)) out[k] = jsonToCanon(x[k]);
    return out;
  }
  throw new MapError("ERR_TYPE","unknown");
}

// ── BIND projection ──

function parsePointer(ptr) {
  if (ptr === "") return [];
  if (!ptr.startsWith("/")) throw new MapError("ERR_SCHEMA","pointer must start with /");
  return ptr.split("/").slice(1).map(raw => {
    let out = "", i = 0;
    while (i < raw.length) {
      if (raw[i] !== '~') { out += raw[i++]; continue; }
      if (i+1 >= raw.length) throw new MapError("ERR_SCHEMA","bad ~");
      if (raw[i+1]==='0') out += '~';
      else if (raw[i+1]==='1') out += '/';
      else throw new MapError("ERR_SCHEMA","bad ~");
      i += 2;
    }
    return out;
  });
}

function bindProject(desc, pointers) {
  if (typeof desc !== 'object' || desc === null || Array.isArray(desc))
    throw new MapError("ERR_SCHEMA","BIND root must be MAP");
  if (new Set(pointers).size !== pointers.length)
    throw new MapError("ERR_SCHEMA","duplicate pointers");

  const parsed = pointers.map(p => [p, parsePointer(p)]);
  const matched = [];
  let anyMatch = false, anyUnmatched = false;

  for (const [ptr, tokens] of parsed) {
    if (ptr === "") { anyMatch = true; continue; }
    let cur = desc, ok = true;
    for (const tok of tokens) {
      if (Array.isArray(cur)) throw new MapError("ERR_SCHEMA","BIND no LIST traversal");
      if (!cur || typeof cur !== 'object' || !(tok in cur)) { ok = false; break; }
      cur = cur[tok];
    }
    if (ok) { anyMatch = true; matched.push(tokens); }
    else anyUnmatched = true;
  }

  if (!anyMatch) return {};
  if (anyUnmatched) throw new MapError("ERR_SCHEMA","unmatched pointer");
  if (parsed.some(([p]) => p === "")) return desc;

  const isSubsumed = (toks) => matched.some(o => o.length < toks.length && toks.slice(0,o.length).every((t,i)=>t===o[i]));
  const effective = matched.filter(t => !isSubsumed(t));

  const proj = {};
  for (const toks of effective) {
    let cur = desc;
    const path = [];
    for (const tok of toks) { path.push([cur, tok]); cur = cur[tok]; }
    let out = proj;
    for (let i = 0; i < path.length; i++) {
      const tok = path[i][1];
      if (i === path.length - 1) { out[tok] = cur; }
      else { if (!out[tok]) out[tok] = {}; out = out[tok]; }
    }
  }
  return proj;
}

// ── Public API ──

async function midFullJson(rawBytes) {
  const parsed = parseJsonStrict(rawBytes);
  const val = jsonToCanon(parsed.v);
  const cb = canonBytes(val);
  if (parsed.dupFound) throw new MapError("ERR_DUP_KEY","dup key in JSON");
  if (parsed.surrogateFound) throw new MapError("ERR_UTF8","surrogate");
  return { mid: "map1:" + await sha256hex(cb), canonBytes: cb };
}

async function midBindJson(rawBytes, ptrs) {
  const parsed = parseJsonStrict(rawBytes);
  const val = jsonToCanon(parsed.v);
  const proj = bindProject(val, ptrs);
  const cb = canonBytes(proj);
  if (parsed.dupFound) throw new MapError("ERR_DUP_KEY","dup key in JSON");
  if (parsed.surrogateFound) throw new MapError("ERR_UTF8","surrogate");
  return { mid: "map1:" + await sha256hex(cb), canonBytes: cb };
}

// ════════════════════════════════════════════════════
// UI
// ════════════════════════════════════════════════════

const EXAMPLES = {
  deploy: {
    json: '{"action": "deploy", "target": "prod", "version": "2.1.0"}',
    mode: 'full', pointers: ''
  },
  nested: {
    json: '{\n  "service": "auth",\n  "config": {\n    "timeout": "30",\n    "retries": "3"\n  },\n  "tags": ["production", "critical"]\n}',
    mode: 'full', pointers: ''
  },
  reorder: {
    json: '{"version": "2.1.0", "action": "deploy", "target": "prod"}',
    mode: 'full', pointers: ''
  },
  bool: {
    json: '{"enabled": true, "verbose": false}',
    mode: 'full', pointers: ''
  },
  'error-num': {
    json: '{"count": 42, "name": "test"}',
    mode: 'full', pointers: ''
  },
  'error-dup': {
    json: '{"a": "first", "a": "second"}',
    mode: 'full', pointers: ''
  }
};

let currentMode = 'full';

// Mode buttons
document.querySelectorAll('.mode-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentMode = btn.dataset.mode;
    document.getElementById('pointers-input').classList.toggle('hidden', currentMode !== 'bind');
  });
});

// Example buttons
document.querySelectorAll('.example-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const ex = EXAMPLES[btn.dataset.example];
    document.getElementById('input-json').value = ex.json;
    if (ex.mode === 'bind') {
      document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
      document.querySelector('[data-mode="bind"]').classList.add('active');
      currentMode = 'bind';
      document.getElementById('pointers-input').classList.remove('hidden');
      document.getElementById('pointers-input').value = ex.pointers;
    }
    compute();
  });
});

// Hex toggle
document.getElementById('hex-toggle').addEventListener('click', function() {
  this.classList.toggle('active');
  document.getElementById('hex-dump').classList.toggle('show');
});

// Copy on click
document.getElementById('mid-output').addEventListener('click', function() {
  const text = this.textContent.replace('copied','').trim();
  if (!text || this.classList.contains('empty')) return;
  navigator.clipboard.writeText(text).then(() => {
    const toast = document.getElementById('copy-toast');
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), 1200);
  });
});

// Compute
document.getElementById('compute-btn').addEventListener('click', compute);
document.getElementById('input-json').addEventListener('keydown', (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') compute();
});

async function compute() {
  const midOut = document.getElementById('mid-output');
  const hexDump = document.getElementById('hex-dump');
  const infoBar = document.getElementById('info-bar');
  const raw = document.getElementById('input-json').value.trim();

  if (!raw) {
    midOut.className = 'mid-display empty';
    midOut.innerHTML = 'paste json and click compute<span class="copy-toast" id="copy-toast">copied</span>';
    hexDump.innerHTML = '';
    infoBar.innerHTML = '';
    return;
  }

  const rawBytes = encoder.encode(raw);

  try {
    let result;
    if (currentMode === 'bind') {
      const ptrStr = document.getElementById('pointers-input').value.trim();
      const ptrs = ptrStr ? ptrStr.split(/\s+/) : [];
      result = await midBindJson(rawBytes, ptrs);
    } else {
      result = await midFullJson(rawBytes);
    }

    midOut.className = 'mid-display';
    const prefix = result.mid.slice(0, 5);
    const hash = result.mid.slice(5);
    midOut.innerHTML = `<span class="prefix">${prefix}</span><span class="hash">${hash}</span><span class="copy-toast" id="copy-toast">copied</span>`;

    // Hex dump
    hexDump.innerHTML = formatHexDump(result.canonBytes);

    // Info bar
    const canonLen = result.canonBytes.length;
    const mode = currentMode.toUpperCase();
    infoBar.innerHTML = `
      <span class="stat">mode: <span>${mode}</span></span>
      <span class="stat">canon_bytes: <span>${canonLen} bytes</span></span>
      <span class="stat">input: <span>${rawBytes.length} bytes</span></span>
    `;
  } catch (e) {
    midOut.className = 'mid-display error';
    midOut.innerHTML = `${e.code || 'ERROR'}: ${e.message}<span class="copy-toast" id="copy-toast">copied</span>`;
    hexDump.innerHTML = '';
    infoBar.innerHTML = `<span class="stat">error: <span>${e.code || 'unknown'}</span></span>`;
  }
}

function formatHexDump(bytes) {
  const lines = [];
  const HDR_LEN = 5;
  const perLine = 16;

  for (let off = 0; off < bytes.length; off += perLine) {
    const chunk = bytes.slice(off, Math.min(off + perLine, bytes.length));
    const offsetStr = `<span class="offset">${off.toString(16).padStart(4,'0')}</span>  `;

    let hexParts = [];
    for (let j = 0; j < chunk.length; j++) {
      const globalOff = off + j;
      const hex = chunk[j].toString(16).padStart(2, '0');
      let cls = 'payload';
      if (globalOff < HDR_LEN) cls = 'hdr';
      else if (globalOff === HDR_LEN) cls = 'tag';
      hexParts.push(`<span class="${cls}">${hex}</span>`);
    }

    // pad to 16
    while (hexParts.length < perLine) hexParts.push('  ');

    let ascii = '';
    for (let j = 0; j < chunk.length; j++) {
      const b = chunk[j];
      ascii += (b >= 0x20 && b <= 0x7e) ? String.fromCharCode(b) : '.';
    }

    lines.push(offsetStr + hexParts.join(' ') + '  ' + ascii);
  }

  return lines.join('\n');
}

// Auto-compute on load
compute();
</script>

</body>
</html>
